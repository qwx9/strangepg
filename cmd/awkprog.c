char *awkprog = "BEGIN{\n"
"	black = 0x00000000\n"
"	blue = 0x1f78b400\n"
"	bluegreen = 0x5fc69f00\n"
"	brightblue = 0x0000ff00\n"
"	brightgreen = 0x00ff0000\n"
"	brightpurple = 0x00ffff00\n"
"	brightred = 0xff000000\n"
"	brightyellow = 0xffff0000\n"
"	brown = 0xb1592800\n"
"	cyan = 0x7acdcd00\n"
"	darkblue = 0x03328500\n"
"	darkgray = 0x3f3f3f00\n"
"	darkgrey = darkgray\n"
"	darkgreen = 0x33a02c00\n"
"	darkpink = 0xc9608800\n"
"	darkpurple = 0x6a3d9a00\n"
"	darksalmon = 0xe9967a00\n"
"	gray = 0x77777700\n"
"	grayblue = 0xbebada00\n"
"	graybrown = 0x7f5f6700\n"
"	graygreen = 0xccebc500\n"
"	grayred = 0xc7675800\n"
"	grey = gray\n"
"	greyblue = grayblue\n"
"	greybrown = graybrown\n"
"	greygreen = graygreen\n"
"	greyred = grayred\n"
"	green = 0x8ec65e00\n"
"	lightblue = 0x80b1d300\n"
"	lightbrown = 0xca956000\n"
"	lightgray = 0xd9d9d900\n"
"	lightgreen = 0xd5f65f00\n"
"	lightgrey = lightgray\n"
"	lightorange = 0xfdb46200\n"
"	lightpink = 0xfccde500\n"
"	lightpurple = 0xbc80bd00\n"
"	lightred = 0xfb807200\n"
"	lightteal = 0x8dd3c700\n"
"	orange = 0xff7f0000\n"
"	paleblue = 0xa6cee300\n"
"	palegray = 0xdcdcdc00\n"
"	palegreen = 0xb2df8a00\n"
"	paleorange = 0xfdbf6f00\n"
"	palepurple = 0xc893f000\n"
"	palered = 0xfb9a9900\n"
"	paleviolet = 0xcab2d600\n"
"	paleyellow = 0xffffb300\n"
"	purple = 0xb160c900\n"
"	purpleblue = 0x8080ff00\n"
"	red = 0xe31a1c00\n"
"	teal = 0x00969600\n"
"	violet = purple\n"
"	white = 0xffffff00\n"
"	yellow = 0xffed6f00\n"
"	translucent = 0xeeeeee30\n"
"	cmap[n++] = blue\n"
"	cmap[n++] = green\n"
"	cmap[n++] = red\n"
"	cmap[n++] = purple\n"
"	cmap[n++] = brown\n"
"	cmap[n++] = orange\n"
"	cmap[n++] = bluegreen\n"
"	cmap[n++] = yellow\n"
"	cmap[n++] = purpleblue\n"
"	cmap[n++] = greyred\n"
"	cmap[n++] = lightbrown\n"
"	cmap[n++] = palepurple\n"
"	cmap[n++] = greybrown\n"
"	cmap[n++] = darkpink\n"
"	cmap[n++] = darkgreen\n"
"	cmap[n++] = darkpurple\n"
"	cmap[n++] = lightteal\n"
"	cmap[n++] = paleyellow\n"
"	cmap[n++] = greyblue\n"
"	cmap[n++] = lightred\n"
"	cmap[n++] = lightblue\n"
"	cmap[n++] = lightorange\n"
"	cmap[n++] = lightgreen\n"
"	cmap[n++] = lightpink\n"
"	cmap[n++] = lightgrey\n"
"	cmap[n++] = lightpurple\n"
"	cmap[n++] = greygreen\n"
"	cmap[n++] = paleblue\n"
"	cmap[n++] = palegreen\n"
"	cmap[n++] = palered\n"
"	cmap[n++] = paleorange\n"
"	cmap[n++] = paleviolet\n"
"	cmap[n] = cyan\n"
"	OFS = \"\\t\"\n"
"}\n"
"function cmd(code){\n"
"	if(code == \"FHJ142\"){	# wing to proceed to targets\n"
"		if(++fnr == nd + 1)\n"
"			cmd(\"FGD135\")\n"
"		else{\n"
"			print deferred[fnr]\n"
"			loadbatch()\n"
"		}\n"
"	}else if(code == \"FJJ142\"){	# mission completed, returning\n"
"		die = 1\n"
"		cmd(\"FHJ142\")\n"
"	}else if(code == \"OPL753\"){	# wing to contact base immediately\n"
"		loadall()\n"
"		print \"R\"\n"
"		crm114 = 1\n"
"	}else if(code == \"FGD135\"){	# wing attack plan R\n"
"		if(crm114 || fnr < nd + 1)\n"
"			return\n"
"		crm114 = 1\n"
"		loadall()\n"
"		if(die)\n"
"			quit()\n"
"		print (noreset ? \"r\" : \"R\")\n"
"	}\n"
"}\n"
"function exportlayout(f){\n"
"	print \"o\", f\n"
"}\n"
"function importlayout(f){\n"
"	if(crm114 == 1)\n"
"		print \"i\", f\n"
"	else{\n"
"		deferred[++nd] = \"i\\t\" f \"\\n\"\n"
"		noreset = 1\n"
"	}\n"
"}\n"
"function readctab(f){\n"
"	if(crm114 == 1)\n"
"		print \"t\", f\n"
"	else\n"
"		deferred[++nd] = \"t\\t\" f \"\\n\"\n"
"}\n"
"function readcsv(f){\n"
"	if(crm114 == 1)\n"
"		print \"f\", f\n"
"	else\n"
"		deferred[++nd] = \"f\\t\" f \"\\n\"\n"
"}\n"
"function checknodeid(id){\n"
"	if(!(id in label)){\n"
"		print \"E\\tno such nodeid: \" id\n"
"		return 0\n"
"	}\n"
"	return 1\n"
"}\n"
"function checknodename(name){\n"
"	if(!(name in node)){\n"
"		print \"E\\tno such node: \" name\n"
"		return 0\n"
"	}\n"
"	return 1\n"
"}\n"
"function edgeinfostr(i,	e, u, v, a, b, s){\n"
"	e = realedge(i)\n"
"	u = e >> 32\n"
"	v = e >> 2 & 0x3fffffff\n"
"	a = e & 1 ? \"-\" : \"+\"\n"
"	b = e & 2 ? \"-\" : \"+\"\n"
"	if(!checknodeid(u) || !checknodeid(v))\n"
"		return\n"
"	s = label[u] a label[v] b\n"
"	if(i in cigar)\n"
"		s = s \", CIGAR=\" cigar[i]\n"
"	return s\n"
"}\n"
"function edgeinfo(i, s){\n"
"	if((s = edgeinfostr(i)) == \"\")\n"
"		return\n"
"	info(\"Edge: \" s)\n"
"}\n"
"function findnode(name,	id){\n"
"	if(!checknodename(name))\n"
"		return\n"
"	id = node[name]\n"
"	selectnodebyid(id)\n"
"	print \"N\", id\n"
"}\n"
"function selinfostr(	id, name, l, n, m, s){\n"
"	if(length(selected) == 0)\n"
"		return \"\"\n"
"	l = 0\n"
"	s = \"\"\n"
"	n = m = 0\n"
"	for(id in selected){\n"
"		name = label[id]\n"
"		if(name in LN)\n"
"			l += LN[name]\n"
"		if(m < 28){\n"
"			m = length(s)\n"
"			s = s (m == 0 ? \"\" : \",\") name\n"
"		}else if(n == 0){\n"
"			n++\n"
"			s = s \",...\"\n"
"		}\n"
"	}\n"
"	s = \"Selected: \" s\n"
"	if(length(selected) == 1)\n"
"		return s \", length=\" l\n"
"	return s \"; total length=\" l \" in \" length(selected) \" nodes\"\n"
"}\n"
"function nodeinfo(id,	name, s){\n"
"	if(!checknodeid(id))\n"
"		return\n"
"	name = label[id]\n"
"	s = \"Node: \" name\n"
"	if(name in LN)\n"
"		s = s \", length=\" LN[name]\n"
"	info(s)\n"
"}\n"
"function deselect(	id){\n"
"	selinfo = \"\"\n"
"	for(id in selected)\n"
"		unshow(id, selected[id])\n"
"	delete selected\n"
"}\n"
"function deselectnodebyid(id,	col){\n"
"	if(!checknodeid(id))\n"
"		return\n"
"	if(!(id in selected)){\n"
"		print \"E\\tdeselect: not selected: \" id\n"
"		return\n"
"	}\n"
"	if(length(selected) == 1){\n"
"		deselect()\n"
"		return\n"
"	}\n"
"	col = selected[id]\n"
"	delete selected[id]\n"
"	selinfo = selinfostr()\n"
"	unshow(id, col)\n"
"}\n"
"function deselectnode(name,	id){\n"
"	if(!checknodename(name))\n"
"		return\n"
"	deselectnodebyid(node[name])\n"
"}\n"
"function showselected(){\n"
"	selinfo = selinfostr()\n"
"	refresh()\n"
"}\n"
"function selectnodebyid(id, noshow){\n"
"	if(!checknodeid(id) || id in selected)\n"
"		return\n"
"	selected[id] = CL[label[id]]\n"
"	if(!noshow)\n"
"		showselected()\n"
"}\n"
"function selectnode(name, id){\n"
"	if(!checknodename(name))\n"
"		return\n"
"	id = node[name]\n"
"	selectnodebyid(id)\n"
"}\n"
"function toggleselect(id){\n"
"	if(!checknodeid(id))\n"
"		return\n"
"	if(id in selected)\n"
"		deselectnodebyid(id)\n"
"	else\n"
"		selectnodebyid(id)\n"
"}\n"
"function reselectnode(id){\n"
"	if(!checknodeid(id))\n"
"		return\n"
"	deselect()\n"
"	selectnodebyid(id)\n"
"}\n"
"# FIXME: can't be variadic, unless in C\n"
"#function collapse(id){\n"
"#	if(id != \"\"){\n"
"#		if(!checknodeid(id))\n"
"#			return\n"
"#		collapse1(id)\n"
"#	}else{\n"
"#		for(id in selected)\n"
"#			collapse1(id)\n"
"#	}\n"
"#	commit()\n"
"#	deselect()\n"
"#}\n"
"function expand(id){\n"
"	if(id != \"\"){\n"
"		if(!checknodeid(id))\n"
"			return\n"
"		expand1(id)\n"
"	}else if(length(selected) > 0){\n"
"		for(id in selected)\n"
"			expand1(id)\n"
"	}else\n"
"		expandall()\n"
"	commit()\n"
"	deselect()\n"
"}\n"
"# FIXME: randomize\n"
"function mkcolormap(	i, colors){\n"
"	for(i in CL){\n"
"		c = CL[i]\n"
"		if(!(c in colors)){\n"
"			colors[c] = \"\"\n"
"			cmap[n++] = c\n"
"		}\n"
"	}\n"
"	delete colors\n"
"}\n"
"function groupby(tag, incl, 	acc, n, m){\n"
"	if(length(cmap) == 0)\n"
"		mkcolormap()\n"
"	if((n = length(cmap)) <= 0){\n"
"		print \"E\", \"no colors to hand\"\n"
"		return\n"
"	}\n"
"	delete acc\n"
"	m = 0\n"
"	# FIXME: error handling in nested evals?\n"
"	if(incl == \"\")\n"
"		eval(\"{for(i in \"tag\"){ c = \"tag\"[i]; if(!(c in acc)) acc[c] = m++; nodecolor(i, cmap[acc[c] % n]) } }\")\n"
"	else\n"
"		eval(\"{for(i in CL){ if(!(i in \"tag\")){ c = translucent }else{ c = \"tag\"[i]; if(c !~ /\"incl\"/) c = translucent; else{ if(!(c in acc)) acc[c] = m++; c = cmap[acc[c] % n] }}; nodecolor(i, c)}}\")\n"
"	if(m > n)\n"
"		print \"E\", \"more categories than colors\"\n"
"}\n"
"function initx(name, x){\n"
"	if(!checknodename(name))\n"
"		return\n"
"	x0[name] = x\n"
"	print \"x\", node[name], x\n"
"}\n"
"function inity(name, y){\n"
"	if(!checknodename(name))\n"
"		return\n"
"	y0[name] = y\n"
"	print \"y\", node[name], y\n"
"}\n"
"function initz(name, z){\n"
"	if(!checknodename(name))\n"
"		return\n"
"	z0[name] = z\n"
"	print \"z\", node[name], z\n"
"}\n"
"function fixx(name, x){\n"
"	if(!checknodename(name))\n"
"		return\n"
"	fx[name] = x\n"
"	print \"X\", node[name], x\n"
"}\n"
"function fixy(name, y){\n"
"	if(!checknodename(name))\n"
"		return\n"
"	fy[name] = y\n"
"	print \"Y\", node[name], y\n"
"}\n"
"function fixz(name, z){\n"
"	if(!checknodename(name))\n"
"		return\n"
"	fz[name] = z\n"
"	print \"Z\", node[name], z\n"
"}\n"
"function quit(){\n"
"	print \"!\"\n"
"}\n"
"# too complicated if nested, and temporary anyway; would ideally expand\n"
"# other tags into tag[i]\n"
"function subexpr(s, v, fn,	i, j, t, pred){\n"
"	i = match(s, \"\\][ 	]*=[^=]\")\n"
"	# error check: i not 0; only sub expression up to } or ; etc\n"
"	pred = substr(s, 1, i-1)\n"
"	s = substr(s, RSTART+RLENGTH-1)\n"
"	# my god man, implement pointers\n"
"	eval(\"{w = length(\" v \") == 0 ? \\\"node\\\" : v}\")\n"
"	$0 = \"for(i in \" w \") if(\" pred \"){ \" fn \"(i, \" s \")}\"\n"
"}\n"
"#crm114 && $1 == function\"{\n"
"#	eval($0)\n"
"#	next\n"
"#}\n"
"crm114 && /^[	 ]*[A-Za-z][A-Za-z0-9 ]*\\[.*\\] *= */{\n"
"	i = index($0, \"[\")\n"
"	v = substr($0, 1, i - 1)\n"
"	s = substr($0, i + 1)\n"
"	if(v == \"CL\" || v ~ /[Cc][Oo][Ll][Oo][Rr]/)\n"
"		subexpr(s, v, \"nodecolor\")\n"
"	else if(v == \"x0\")\n"
"		subexpr(s, v, \"initx\")\n"
"	else if(v == \"y0\")\n"
"		subexpr(s, v, \"inity\")\n"
"	else if(v == \"fx\")\n"
"		subexpr(s, v, \"fixx\")\n"
"	else if(v == \"fy\")\n"
"		subexpr(s, v, \"fixy\")\n"
"}\n"
"{\n"
"	i = \"\"\n"
"	eval(\"{\" $0 \"}\")\n"
"}\n";
