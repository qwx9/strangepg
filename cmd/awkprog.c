char *awkprog = "BEGIN{\n"
"	black = 0x00000000\n"
"	blue = 0x1f78b400\n"
"	bluegreen = 0x00cc7700\n"
"	brightblue = 0x0000ff00\n"
"	brightcyan = 0x00ffff00\n"
"	brightgreen = 0x00ff0000\n"
"	brightpurple = 0xff00ff00\n"
"	brightred = 0xff000000\n"
"	brightyellow = 0xffff0000\n"
"	brown = 0xb1592800\n"
"	cyan = 0x4ddfdf00\n"
"	darkblue = 0x03328500\n"
"	darkgray = 0x3f3f3f00\n"
"	darkgreen = 0x549f2c00\n"
"	darkgrey = darkgray\n"
"	darkpink = 0xd7548900\n"
"	darkpurple = 0x6a3d9a00\n"
"	darksalmon = 0xe9967a00\n"
"	gray = 0x77777700\n"
"	grayblue = 0xbebada00\n"
"	graybrown = 0x7f5f6700\n"
"	graygreen = 0xa5e39500\n"
"	grayred = 0xc7675800\n"
"	green = 0x74d04100\n"
"	grey = gray\n"
"	greyblue = grayblue\n"
"	greybrown = graybrown\n"
"	greygreen = graygreen\n"
"	greyred = grayred\n"
"	lightblue = 0x80b1d300\n"
"	lightbrown = 0xca956000\n"
"	lightgray = 0xb6b6b600\n"
"	lightgreen = 0x88f03b00\n"
"	lightgrey = lightgray\n"
"	lightorange = 0xfba72400\n"
"	lightpink = 0xfbacd600\n"
"	lightpurple = 0xbc80bd00\n"
"	lightred = 0xfa3e4300\n"
"	lightteal = 0x7fe0cf00\n"
"	olive = 0x7ab64100\n"
"	orange = 0xff7f0000\n"
"	paleblue = 0xa6cee300\n"
"	palegray = 0xdcdcdc00\n"
"	palegreen = 0x94fb6a00\n"
"	paleorange = 0xfdbf6f00\n"
"	palepurple = 0xc893f000\n"
"	palered = 0xfb696700\n"
"	paleviolet = 0xcab2d600\n"
"	paleyellow = 0xffeb4900\n"
"	pink = 0xffb6c100\n"
"	purple = 0xb160c900\n"
"	purpleblue = 0x6481fc00\n"
"	red = 0xda181a00\n"
"	tan = 0xd2b48c00\n"
"	teal = 0x00bbbb00\n"
"	violet = purple\n"
"	white = 0xffffff00\n"
"	yellow = 0xe7d94100\n"
"	yellowgreen = 0xd5ef0000\n"
"	translucent = 0xdfdfdf60\n"
"	n = 0\n"
"	# named palettes courtesy of colorbrewer\n"
"	defgrp[n++] = greyblue\n"
"	defgrp[n++] = paleblue\n"
"	defgrp[n++] = lightblue\n"
"	defgrp[n++] = blue\n"
"	defgrp[n++] = purpleblue\n"
"	defgrp[n++] = darkblue\n"
"	defgrp[n++] = bluegreen\n"
"	defgrp[n++] = darkgreen\n"
"	defgrp[n++] = green\n"
"	defgrp[n++] = lightgreen\n"
"	defgrp[n++] = palegreen\n"
"	defgrp[n++] = greygreen\n"
"	defgrp[n++] = greyred\n"
"	defgrp[n++] = palered\n"
"	defgrp[n++] = lightred\n"
"	defgrp[n++] = red\n"
"	defgrp[n++] = orange\n"
"	defgrp[n++] = lightorange\n"
"	defgrp[n++] = paleorange\n"
"	defgrp[n++] = palepurple\n"
"	defgrp[n++] = paleviolet\n"
"	defgrp[n++] = lightpurple\n"
"	defgrp[n++] = purple\n"
"	defgrp[n++] = darkpurple\n"
"	defgrp[n++] = darkbrown\n"
"	defgrp[n++] = greybrown\n"
"	defgrp[n++] = brown\n"
"	defgrp[n++] = lightbrown\n"
"	defgrp[n++] = paleyellow\n"
"	defgrp[n++] = yellow\n"
"	defgrp[n++] = tan\n"
"	defgrp[n++] = lightteal\n"
"	defgrp[n++] = lightgrey\n"
"	n = 0\n"
"	set1[n++] = 0xe41a1c00\n"
"	set1[n++] = 0x377eb800\n"
"	set1[n++] = 0x4daf4a00\n"
"	set1[n++] = 0x984ea300\n"
"	set1[n++] = 0xff7f0000\n"
"	set1[n++] = 0xffff3300\n"
"	set1[n++] = 0xa5452800\n"
"	set1[n++] = 0xf781bf00\n"
"	set1[n++] = 0x99999900\n"
"	n = 0\n"
"	set2[n++] = 0x66c2a500\n"
"	set2[n++] = 0xfc8d6200\n"
"	set2[n++] = 0x8da0cb00\n"
"	set2[n++] = 0xe78ac300\n"
"	set2[n++] = 0xa6d85400\n"
"	set2[n++] = 0xffd92f00\n"
"	set2[n++] = 0xe4c49400\n"
"	set2[n++] = 0xb3b3b300\n"
"	n = 0\n"
"	set3[n++] = 0x8dd3c700\n"
"	set3[n++] = 0xffffb300\n"
"	set3[n++] = 0xbebada00\n"
"	set3[n++] = 0xfb807200\n"
"	set3[n++] = 0x80b1d300\n"
"	set3[n++] = 0xfdb46200\n"
"	set3[n++] = 0xb3de6900\n"
"	set3[n++] = 0xfccde500\n"
"	set3[n++] = 0xd9d9d900\n"
"	set3[n++] = 0xbc80bd00\n"
"	set3[n++] = 0xccebc500\n"
"	set3[n++] = 0xffed6f00\n"
"	n = 0\n"
"	paired[n++] = 0xa6cee300\n"
"	paired[n++] = 0x1f78b400\n"
"	paired[n++] = 0xb2df8a00\n"
"	paired[n++] = 0x33a02c00\n"
"	paired[n++] = 0xfb9a9900\n"
"	paired[n++] = 0xe31a1c00\n"
"	paired[n++] = 0xfdbf6f00\n"
"	paired[n++] = 0xff7f0000\n"
"	paired[n++] = 0xcab2d600\n"
"	paired[n++] = 0x6a3d9a00\n"
"	paired[n++] = 0xffff9900\n"
"	paired[n++] = 0xb1592800\n"
"	n = 0\n"
"	spectral[n++] = 0x5e4fa200\n"
"	spectral[n++] = 0x3288bd00\n"
"	spectral[n++] = 0x66c2a500\n"
"	spectral[n++] = 0xabdda400\n"
"	spectral[n++] = 0xe6f59800\n"
"	spectral[n++] = 0xffffbf00\n"
"	spectral[n++] = 0xfee08b00\n"
"	spectral[n++] = 0xfdae6100\n"
"	spectral[n++] = 0xf45d4300\n"
"	spectral[n++] = 0xd53e4f00\n"
"	spectral[n++] = 0x9e014200\n"
"	n = 0\n"
"	default[n++] = purpleblue\n"
"	default[n++] = green\n"
"	default[n++] = greyred\n"
"	default[n++] = lightbrown\n"
"	default[n++] = palepurple\n"
"	default[n++] = greybrown\n"
"	default[n++] = purple\n"
"	default[n++] = lightteal\n"
"	default[n++] = darkpink\n"
"	default[n++] = blue\n"
"	default[n++] = orange\n"
"	default[n++] = darkgreen\n"
"	default[n++] = red\n"
"	default[n++] = darkpurple\n"
"	default[n++] = brown\n"
"	default[n++] = lightteal\n"
"	default[n++] = greyblue\n"
"	default[n++] = tan\n"
"	default[n++] = darksalmon\n"
"	default[n++] = olive\n"
"	default[n++] = yellowgreen\n"
"	default[n++] = lightgreen\n"
"	default[n++] = lightred\n"
"	default[n++] = lightblue\n"
"	default[n++] = lightorange\n"
"	default[n++] = lightpurple\n"
"	default[n++] = lightgrey\n"
"	default[n++] = lightpink\n"
"	default[n++] = greygreen\n"
"	default[n++] = yellow\n"
"	default[n++] = paleblue\n"
"	default[n++] = palered\n"
"	default[n++] = palegreen\n"
"	default[n++] = paleorange\n"
"	default[n++] = paleviolet\n"
"	default[n++] = cyan\n"
"	OFS = \"\\t\"\n"
"	Fgraph = 1<<0	# FIXME: make awk2c a preprocessor in awk,\n"
"	Fctab = 1<<1	#   then replace these as constants?\n"
"	Fflayout = 1<<2\n"
"	Ffctab = 1<<3\n"
"	Ffcsv = 1<<4\n"
"	Fdie = 1<<5\n"
"	Fcrm114 = 1<<15\n"
"}\n"
"function setdefcols(	n, i){\n"
"	n = length(default)\n"
"	for(i in CL)\n"
"		if(!(i in CL))\n"
"			CL[i] = default[i % n]\n"
"		else\n"
"			CL[i] = CL[i]\n"
"}\n"
"# FIXME: CL changes currently are still destructive, would be\n"
"# nice to be able to actually reset them to the initial values\n"
"# FIXME: use after free if using i as temp and not a param\n"
"function cmd(code, _i, __i){\n"
"	if(code == \"OPL753\"){		# wing to contact base immediately\n"
"		flags |= Fdie\n"
"		if(flags & Ffctab == 0)\n"
"			flags |= Fctab\n"
"	}else if(code == \"FGG138\"){	# wing report mission completed\n"
"		#if(flags & Fcrm114 == 0)\n"
"		#	nd--\n"
"	}else if(code == \"JIK485\"){	# mission completed returning\n"
"		if(flags & Fcrm114 == 0)\n"
"			nd--\n"
"		loadbatch()\n"
"	}else if(code == \"FHJ142\"){	# wing to proceed to targets\n"
"		if(flags & Fcrm114 == 0)\n"
"			nd--\n"
"		loadbatch()\n"
"	}else if(code == \"HGI234\"){	# wing holding at fail safe point\n"
"		flags |= Fctab\n"
"		if(flags & (Fcrm114|Ffctab) == Ffctab)\n"
"			nd--\n"
"	}else if(code == \"FGD135\"){	# wing attack plan R\n"
"		flags |= Fgraph\n"
"		nd = length(deferred)\n"
"		for(_i in deferred)\n"
"			print deferred[_i]\n"
"		delete deferred\n"
"		loadbatch()\n"
"	}\n"
"	if(nd <= 0 && flags & (Fcrm114|Fgraph|Fctab) == (Fgraph|Fctab)){\n"
"		loadbatch()\n"
"		if(flags & Fdie)\n"
"			quit()\n"
"		arm()\n"
"		setdefcols()	# FIXME: until rnodes are gone\n"
"		if(length(deferredexpr) != 0){	# FIXME: after arm because of rnodes\n"
"			for(_i=1; _i<=length(deferredexpr); _i++)\n"
"				eval(\"{\"deferredexpr[_i]\"}\")\n"
"			delete deferredexpr\n"
"		}\n"
"		# must be done after arming rnodes\n"
"		if(length(layout) > 0){\n"
"			flags |= Fflayout\n"
"			for(_i=1; _i<=length(layout); _i++)\n"
"				print \"i\\t\" layout[_i] \"\\n\"\n"
"			delete layout\n"
"		}\n"
"		flags |= Fcrm114\n"
"		print (flags & Fflayout ? \"r\" : \"R\")\n"
"	}\n"
"}\n"
"function exportlayout(f){\n"
"	print \"o\", f\n"
"}\n"
"function importlayout(f){\n"
"	if(flags & Fcrm114)\n"
"		print \"i\", f\n"
"	else{\n"
"		layout[length(layout)+1] = f\n"
"		flags |= Fflayout\n"
"	}\n"
"}\n"
"function readctab(f){\n"
"	if(flags & Fcrm114)\n"
"		print \"t\", f\n"
"	else{\n"
"		deferred[length(deferred)+1] = \"t\\t\" f \"\\n\"\n"
"		flags |= Ffctab\n"
"	}\n"
"}\n"
"function readcsv(f){\n"
"	if(flags & Fcrm114)\n"
"		print \"f\", f\n"
"	else{\n"
"		deferred[length(deferred)+1] = \"f\\t\" f \"\\n\"\n"
"		flags |= Ffcsv\n"
"	}\n"
"}\n"
"function checkselected(	i){\n"
"	for(i in selected)\n"
"		if(typeof(selected[i]) == 3 && selected[i] == \"\")\n"
"			delete selected[i]\n"
"}\n"
"function checknodeid(i){\n"
"	if(i < 0 || i >= length(node)){\n"
"		print \"E\\id out of bounds: \" i\n"
"		return 0\n"
"	}\n"
"	return 1\n"
"}\n"
"function checknodename(name){\n"
"	if(!(name in id)){\n"
"		print \"E\\tno such node: \" name\n"
"		return 0\n"
"	}\n"
"	return 1\n"
"}\n"
"function edgeinfostr(u, v, a, b, e,	s){\n"
"	s = node[u] a node[v] b\n"
"	if(e == \"\")\n"
"		return s\n"
"	xxx = \"\"	# has to be global for eval\n"
"	xxe = e\n"
"	for(a in EATTACHED){\n"
"		eval(\"{ xxx = (xxe in \" a \") ? \" a \"[xxe] : \\\"\\\" }\")\n"
"		if(xxx != \"\"){\n"
"			if(a ~ /^e..$/)\n"
"				a = substr(a, 2)\n"
"			s = s \" \" a \"=\" xxx\n"
"		}\n"
"	}\n"
"	return s\n"
"}\n"
"function edgeinfo(w, e,	u, v, a, b){\n"
"	u = w >> 32\n"
"	v = w >> 2 & 0x3fffffff\n"
"	if(!checknodeid(u) || !checknodeid(v))\n"
"		return\n"
"	a = w & 1 ? \"-\" : \"+\"\n"
"	b = w & 2 ? \"-\" : \"+\"\n"
"	info(\"Edge: \" edgeinfostr(u, v, a, b, e))\n"
"}\n"
"function findnode(name,	i){\n"
"	if(!checknodename(name))\n"
"		return\n"
"	i = id[name]\n"
"	expand1(i, 0)\n"
"	commit(1)\n"
"	reselectnode(i)\n"
"	print \"N\", i\n"
"}\n"
"# FIXME: cache it?\n"
"function nodeinfostr(i,	a, s){\n"
"	s = node[i] \", LN=\" LN[i]\n"
"	xxx = \"\"	# has to be global for eval\n"
"	xxi = i\n"
"	for(a in ATTACHED){\n"
"		if(a == \"degree\" || a == \"LN\" || a == \"CL\")\n"
"			continue\n"
"		eval(\"{ xxx = (xxi in \" a \") ? \" a \"[xxi] : \\\"\\\" }\")\n"
"		if(xxx != \"\")\n"
"			s = s \" \" a \"=\" xxx\n"
"	}\n"
"	return s\n"
"}\n"
"function selinfostr(	x, i, l, n, m, s){\n"
"	if(length(selected) == 0)\n"
"		return \"\"\n"
"	# very deliberate and assuming nodes for now\n"
"	if(length(selected) == 1)\n"
"		for(i in selected)\n"
"			return \"Selected: \" nodeinfostr(selected[i])\n"
"	l = 0\n"
"	s = \"\"\n"
"	n = m = 0\n"
"	for(x in selected){\n"
"		i = selected[x]\n"
"		l += LN[i]\n"
"		if(m < 5){\n"
"			m = length(s)\n"
"			s = s (m == 0 ? \"\" : \",\") node[i]\n"
"		}else if(n == 0){\n"
"			n++\n"
"			s = s \",...\"\n"
"		}\n"
"	}\n"
"	s = \"Selected: \" s\n"
"	if(length(selected) == 1)\n"
"		return s \", length=\" l\n"
"	return s \"; total length=\" l \" in \" length(selected) \" nodes\"\n"
"}\n"
"function nodeinfo(i,	name, s){\n"
"	if(!checknodeid(i))\n"
"		return\n"
"	s = \"Node: \" nodeinfostr(i)\n"
"	info(s)\n"
"}\n"
"function deselectnodebyid(i){\n"
"	if(!checknodeid(i) || !(i in selected))\n"
"		return\n"
"	delete selected[i]\n"
"}\n"
"function selectnodebyid(i){\n"
"	if(!checknodeid(i) || i in selected)\n"
"		return\n"
"	selected[i] = int(i)\n"
"}\n"
"function showselected(){\n"
"	selinfo = selinfostr()\n"
"	refresh()\n"
"}\n"
"function deselect(	x, i){\n"
"	selinfo = \"\"\n"
"	delete selected\n"
"}\n"
"function selectall(i){\n"
"	for(i in node)\n"
"		selectnodebyid(i)\n"
"	showselected()\n"
"}\n"
"function deselectnode(name,	i){\n"
"	if(!checknodename(name))\n"
"		return\n"
"	deselectnodebyid(id[name])\n"
"	showselected()\n"
"}\n"
"function selectnode(name){\n"
"	if(!checknodename(name))\n"
"		return\n"
"	selectnodebyid(id[name])\n"
"	showselected()\n"
"}\n"
"function reselectnode(i){\n"
"	if(!checknodeid(i))\n"
"		return\n"
"	if(length(selected) > 1 || !(i in selected))\n"
"		deselect()\n"
"	if(!(i in selected))\n"
"		selected[i] = int(i)\n"
"}\n"
"function toggleselect(i){\n"
"	if(!checknodeid(i))\n"
"		return\n"
"	if(i in selected)\n"
"		deselectnodebyid(i)\n"
"	else\n"
"		selectnodebyid(i)\n"
"}\n"
"function expand(name, full,	x, i){\n"
"	if(name != \"\"){\n"
"		expand1(id[i], !!full)\n"
"	}else if(length(selected) > 0){\n"
"		for(i in selected)\n"
"			expand1(selected[i], !!full)\n"
"	}else\n"
"		expandall()\n"
"	commit()\n"
"	deselect()\n"
"}\n"
"function redraw(){\n"
"	print \"D\"\n"
"}\n"
"function explode(d,	i){\n"
"	if(length(selected) == 0)\n"
"		return\n"
"	if(d == \"\" || float(d) <= 0)\n"
"		d = 8.0\n"
"	for(i in selected)\n"
"		explode1(selected[i], d)\n"
"	redraw()\n"
"}\n"
"function groupby(tag, incl, cm,	acc){\n"
"	delete acc\n"
"	m_ = n_ = 0	# have to be global for eval\n"
"	if(cm == \"\")\n"
"		cm = \"defgrp\"\n"
"	else if(!(cm in SYMTAB)){\n"
"		print \"E\\tno such color palette\"\n"
"		return\n"
"	}\n"
"	eval(\"{n_ = length(\"cm\")}\")\n"
"	if(n_ <= 1){\n"
"		print \"E\\tinvalid color palette\"\n"
"		return\n"
"	}\n"
"	if(incl == \"\")\n"
"		eval(\"{for(i in \"tag\"){ c = \"tag\"[i]; if(!(c in acc)){ if(int(c) != 0) acc[c] = c; else acc[c] = m_++}; CL[i] = \"cm\"[acc[c] % n_] } }\")\n"
"	else\n"
"		eval(\"{for(i in CL){ if(!(i in \"tag\")){ c = translucent }else{ c = \"tag\"[i]; if(c !~ /\"incl\"/) c = translucent; else{ if(!(c in acc)) acc[c] = m_++; c = \"cm\"[acc[c] % n_] }}; CL[i] = c}}\")\n"
"	if(m_ > n_)\n"
"		print \"warning: more categories than colors\"\n"
"	delete acc\n"
"}\n"
"function quit(){\n"
"	print \"Q\"\n"
"	exit\n"
"}\n"
"function longform(){\n"
"	n = index($0, \"[\")\n"
"	v = substr($0, 1, n - 1)\n"
"	s = substr($0, n + 1)\n"
"	n = match(s, \"\\][ \\t]*=[^=]\")\n"
"	pred = substr(s, 1, n-1)\n"
"	s = substr(s, RSTART+RLENGTH-1)\n"
"	# nested i won't be recognized either\n"
"	if(pred ~ /^[ \\t]*i[ \\t]*$/)\n"
"		$0 = \"for(i in \" v \"){ \" v \"[i]=\" s \"}\"\n"
"	else if(pred !~ /^[ \\t]*(\"[^\"]+\"|[a-zA-Z0-9][a-zA-Z0-9_]*|[a-zA-Z0-9][a-zA-Z0-9_]*\\[[\"a-zA-Z0-9_ \\t]+\\])[ \\t]*$/)\n"
"		$0 = \"for(i in \" v \") if(\" pred \"){ \" v \"[i]=\" s \"}\"\n"
"}\n"
"flags & Fcrm114 && /^[A-Za-z0-9_ \\t]+\\[.+\\][ \\t]*=[^=]/{\n"
"	longform()\n"
"}\n"
"$1 == \"defer\"{\n"
"	if(flags & Fcrm114)\n"
"		next\n"
"	$1 = \"\"\n"
"	if(/^[A-Za-z0-9_ \\t]+\\[.+\\][ \\t]*=[^=]/)\n"
"		longform()\n"
"	deferredexpr[length(deferredexpr)+1] = $0\n"
"	next\n"
"}\n"
"{\n"
"	ns = length(selected)\n"
"	eval(\"{\" $0 \"}\")\n"
"	if(ns != length(selected) && length(selected) != 0)\n"
"		checkselected()\n"
"}\n";
