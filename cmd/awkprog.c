char *awkprog = "BEGIN{\n"
"	red = \"0xff0000\"\n"
"	green = \"0x00ff00\"\n"
"	blue = \"0x0000ff\"\n"
"	orange = \"0xffff00\"\n"
"	yellow = \"0xff7f00\"\n"
"	grey = \"0xffff00\"\n"
"	brown = \"0x7f3f00\"\n"
"	black = \"0x0\"\n"
"	white = \"0xffffff\"\n"
"	lightblue = \"0x1f78b4\"\n"
"	lightorange = \"0xff7f00\"\n"
"	lightgreen = \"0x33a02c\"\n"
"	lightred = \"0xe31a1c\"\n"
"	violet = \"0x6a3d9a\"\n"
"	lightbrown = \"0xb15928\"\n"
"	paleblue = \"0x8080ff\"\n"
"	palegreen = \"0x8ec65e\"\n"
"	palered = \"0xc76758\"\n"
"	paleorange = \"0xca9560\"\n"
"	paleviolet = \"0xc893f0\"\n"
"	greybrown = \"0x7f5f67\"\n"
"	lightviolet = \"0xb160c9\"\n"
"	palebluegreen = \"0x5fc69f\"\n"
"	pinkviolet = \"0xc96088\"\n"
"	cyan = \"0x8dd3c7\"\n"
"	paleyellow = \"0xffffb3\"\n"
"	greyblue = \"0xbebada\"\n"
"	lightorange2 = \"0xfb8072\"\n"
"	lightblue2 = \"0x80b1d3\"\n"
"	lightorange2 = \"0xfdb462\"\n"
"	lightgreen2 = \"0xb3de69\"\n"
"	greypink = \"0xfccde5\"\n"
"	lightgrey = \"0xd9d9d9\"\n"
"	lightviolet = \"0xbc80bd\"\n"
"	greygreen = \"0xccebc5\"\n"
"	lightyellow = \"0xffed6f\"\n"
"	lightblue2 = \"0xa6cee3\"\n"
"	lightgreen3 = \"0xb2df8a\"\n"
"	lightpink = \"0xfb9a99\"\n"
"	lightorange3 = \"0xfdbf6f\"\n"
"	greyviolet = \"0xcab2d6\"\n"
"	paleyellow = \"0xffff99\"\n"
"}\n"
"# for now, doing everything with id's, not names\n"
"function nodecolor(id, c){\n"
"	if(!(id in lnode)){\n"
"		print \"E no such node\"\n"
"		return\n"
"	}\n"
"	color[lnode[id]] = c\n"
"	print \"C\", id, c\n"
"}\n"
"function fix(id, x, y){\n"
"	if(y == \"\")\n"
"		y = 0\n"
"	fx[id] = x\n"
"	fy[id] = y\n"
"	print \"x\", id, x, y\n"
"}\n"
"# FIXME: we're now in between awk and fawk; these could become all\n"
"# functions and avoid having to match against every pattern, but we\n"
"# also don't want to quote strings unless necessary, etc.;  figure\n"
"# this out later\n"
"$1 == \"n\"{\n"
"	if($2 in lnode)\n"
"		delete node[lnode[$2]]\n"
"	node[$3] = $2\n"
"	lnode[$2] = $3\n"
"	if(NF > 3)\n"
"		color[$2] = $4\n"
"	next\n"
"}\n"
"$1 == \"e\"{\n"
"	e = $3 \"\\x1c\" $4\n"
"	edge[e] = $2\n"
"	ledge[$2] = e\n"
"	next\n"
"}\n"
"$1 == \"d\"{\n"
"	delete node[lnode[$2]]\n"
"	delete lnode[$2]\n"
"	next\n"
"}\n"
"$1 == \"c\"{\n"
"	id = ledge[$2]\n"
"	delete edge[id]\n"
"	delete ledge[$2]\n"
"	next\n"
"}\n"
"$1 == \"C\"{\n"
"	id = edge[$2,$3]\n"
"	delete ledge[id]\n"
"	delete edge[$2,$3]\n"
"	next\n"
"}\n"
"# FIXME: not distinguishing between node/edge? should we?\n"
"$1 == \"s\"{\n"
"	if($2 == \"cig\"){ cig[$3] = $4 }\n"
"	else if($2 == \"color\"){ color[$3] = $4 }\n"
"	# maybe this alone is sufficient?\n"
"	# FIXME: useless if eval works\n"
"	else{\n"
"		k = $2 \"\\1xc\" $3\n"
"		if(!(k in sym)){\n"
"			lhs[$2]++\n"
"			rhs[$2] = rhs[$2] \"\\1xc\" $3\n"
"		}\n"
"		sym[k] = $4\n"
"	}\n"
"	next\n"
"}\n"
"# tokenize and eval expression in the same way? combined with\n"
"# not distinguishing between node/edge/etc, pretty generic; in\n"
"# the end this is going to be our repl...\n"
"/^[ \\t]*node\\[[^\\]]+\\][ \\t]*$/{\n"
"	gsub(OFS\"|node\\\\[|\\\\]\", \"\")\n"
"	s = lnode[$1]\n"
"	if($1 in NLN)\n"
"		s = s \", LN=\" NLN[$1]\n"
"	if($1 in color)\n"
"		s = s \", color=\" color[$1]\n"
"	print \"node\", $1, s\n"
"	next\n"
"}\n"
"/^[ \\t]*edge\\[[^\\]]+\\][ \\t]*$/{\n"
"	gsub(OFS\"|edge\\\\[|\\\\]\", \"\")\n"
"	s = ledge[$1]\n"
"	if($1 in cig)\n"
"		s = s \", overlap=\" cig[$1]\n"
"	print \"edge\", $1, s\n"
"	next\n"
"}\n"
"/^FGD135$/{\n"
"	crm114 = 1\n"
"	next\n"
"}\n"
"{\n"
"	eval(\"{\" $0 \"}\")\n"
"}\n";
