char *awkprog = "BEGIN{\n"
"	black = 0x00000000\n"
"	blue = 0x1f78b400\n"
"	bluegreen = 0x00cc7700\n"
"	brightblue = 0x0000ff00\n"
"	brightcyan = 0x00ffff00\n"
"	brightgreen = 0x00ff0000\n"
"	brightpurple = 0xff00ff00\n"
"	brightred = 0xff000000\n"
"	brightyellow = 0xffff0000\n"
"	brown = 0xb1592800\n"
"	cyan = 0x4ddfdf00\n"
"	darkblue = 0x03328500\n"
"	darkgray = 0x3f3f3f00\n"
"	darkgreen = 0x549f2c00\n"
"	darkgrey = darkgray\n"
"	darkpink = 0xd7548900\n"
"	darkpurple = 0x6a3d9a00\n"
"	darksalmon = 0xe9967a00\n"
"	gray = 0x77777700\n"
"	grayblue = 0xbebada00\n"
"	graybrown = 0x7f5f6700\n"
"	graygreen = 0xa5e39500\n"
"	grayred = 0xc7675800\n"
"	green = 0x74d04100\n"
"	grey = gray\n"
"	greyblue = grayblue\n"
"	greybrown = graybrown\n"
"	greygreen = graygreen\n"
"	greyred = grayred\n"
"	lightblue = 0x80b1d300\n"
"	lightbrown = 0xca956000\n"
"	lightgray = 0xb6b6b600\n"
"	lightgreen = 0x88f03b00\n"
"	lightgrey = lightgray\n"
"	lightorange = 0xfba72400\n"
"	lightpink = 0xfbacd600\n"
"	lightpurple = 0xbc80bd00\n"
"	lightred = 0xfa3e4300\n"
"	lightteal = 0x7fe0cf00\n"
"	olive = 0x7ab64100\n"
"	orange = 0xff7f0000\n"
"	paleblue = 0xa6cee300\n"
"	palegray = 0xdcdcdc00\n"
"	palegreen = 0x94fb6a00\n"
"	paleorange = 0xfdbf6f00\n"
"	palepurple = 0xc893f000\n"
"	palered = 0xfb696700\n"
"	paleviolet = 0xcab2d600\n"
"	paleyellow = 0xffeb4900\n"
"	pink = 0xffb6c100\n"
"	purple = 0xb160c900\n"
"	purpleblue = 0x6481fc00\n"
"	red = 0xda181a00\n"
"	tan = 0xd2b48c00\n"
"	teal = 0x00bbbb00\n"
"	violet = purple\n"
"	white = 0xffffff00\n"
"	yellow = 0xe7d94100\n"
"	yellowgreen = 0xd5ef0000\n"
"	translucent = 0xaaaaaa20\n"
"	n = 0\n"
"	# named palettes courtesy of colorbrewer\n"
"	defgrp[n++] = greyblue\n"
"	defgrp[n++] = paleblue\n"
"	defgrp[n++] = lightblue\n"
"	defgrp[n++] = blue\n"
"	defgrp[n++] = purpleblue\n"
"	defgrp[n++] = darkblue\n"
"	defgrp[n++] = bluegreen\n"
"	defgrp[n++] = darkgreen\n"
"	defgrp[n++] = green\n"
"	defgrp[n++] = lightgreen\n"
"	defgrp[n++] = palegreen\n"
"	defgrp[n++] = greygreen\n"
"	defgrp[n++] = greyred\n"
"	defgrp[n++] = palered\n"
"	defgrp[n++] = lightred\n"
"	defgrp[n++] = red\n"
"	defgrp[n++] = orange\n"
"	defgrp[n++] = lightorange\n"
"	defgrp[n++] = paleorange\n"
"	defgrp[n++] = palepurple\n"
"	defgrp[n++] = paleviolet\n"
"	defgrp[n++] = lightpurple\n"
"	defgrp[n++] = purple\n"
"	defgrp[n++] = darkpurple\n"
"	defgrp[n++] = darkbrown\n"
"	defgrp[n++] = greybrown\n"
"	defgrp[n++] = brown\n"
"	defgrp[n++] = lightbrown\n"
"	defgrp[n++] = paleyellow\n"
"	defgrp[n++] = yellow\n"
"	defgrp[n++] = tan\n"
"	defgrp[n++] = lightteal\n"
"	defgrp[n++] = lightgrey\n"
"	n = 0\n"
"	set1[n++] = 0xe41a1c00\n"
"	set1[n++] = 0x377eb800\n"
"	set1[n++] = 0x4daf4a00\n"
"	set1[n++] = 0x984ea300\n"
"	set1[n++] = 0xff7f0000\n"
"	set1[n++] = 0xffff3300\n"
"	set1[n++] = 0xa5452800\n"
"	set1[n++] = 0xf781bf00\n"
"	set1[n++] = 0x99999900\n"
"	n = 0\n"
"	set2[n++] = 0x66c2a500\n"
"	set2[n++] = 0xfc8d6200\n"
"	set2[n++] = 0x8da0cb00\n"
"	set2[n++] = 0xe78ac300\n"
"	set2[n++] = 0xa6d85400\n"
"	set2[n++] = 0xffd92f00\n"
"	set2[n++] = 0xe4c49400\n"
"	set2[n++] = 0xb3b3b300\n"
"	n = 0\n"
"	set3[n++] = 0x8dd3c700\n"
"	set3[n++] = 0xffffb300\n"
"	set3[n++] = 0xbebada00\n"
"	set3[n++] = 0xfb807200\n"
"	set3[n++] = 0x80b1d300\n"
"	set3[n++] = 0xfdb46200\n"
"	set3[n++] = 0xb3de6900\n"
"	set3[n++] = 0xfccde500\n"
"	set3[n++] = 0xd9d9d900\n"
"	set3[n++] = 0xbc80bd00\n"
"	set3[n++] = 0xccebc500\n"
"	set3[n++] = 0xffed6f00\n"
"	n = 0\n"
"	paired[n++] = 0xa6cee300\n"
"	paired[n++] = 0x1f78b400\n"
"	paired[n++] = 0xb2df8a00\n"
"	paired[n++] = 0x33a02c00\n"
"	paired[n++] = 0xfb9a9900\n"
"	paired[n++] = 0xe31a1c00\n"
"	paired[n++] = 0xfdbf6f00\n"
"	paired[n++] = 0xff7f0000\n"
"	paired[n++] = 0xcab2d600\n"
"	paired[n++] = 0x6a3d9a00\n"
"	paired[n++] = 0xffff9900\n"
"	paired[n++] = 0xb1592800\n"
"	n = 0\n"
"	spectral[n++] = 0x5e4fa200\n"
"	spectral[n++] = 0x3288bd00\n"
"	spectral[n++] = 0x66c2a500\n"
"	spectral[n++] = 0xabdda400\n"
"	spectral[n++] = 0xe6f59800\n"
"	spectral[n++] = 0xffffbf00\n"
"	spectral[n++] = 0xfee08b00\n"
"	spectral[n++] = 0xfdae6100\n"
"	spectral[n++] = 0xf45d4300\n"
"	spectral[n++] = 0xd53e4f00\n"
"	spectral[n++] = 0x9e014200\n"
"	n = 0\n"
"	default[n++] = purpleblue\n"
"	default[n++] = green\n"
"	default[n++] = greyred\n"
"	default[n++] = lightbrown\n"
"	default[n++] = palepurple\n"
"	default[n++] = greybrown\n"
"	default[n++] = purple\n"
"	default[n++] = lightteal\n"
"	default[n++] = darkpink\n"
"	default[n++] = blue\n"
"	default[n++] = orange\n"
"	default[n++] = darkgreen\n"
"	default[n++] = red\n"
"	default[n++] = darkpurple\n"
"	default[n++] = brown\n"
"	default[n++] = lightteal\n"
"	default[n++] = greyblue\n"
"	default[n++] = tan\n"
"	default[n++] = darksalmon\n"
"	default[n++] = olive\n"
"	default[n++] = yellowgreen\n"
"	default[n++] = lightgreen\n"
"	default[n++] = lightred\n"
"	default[n++] = lightblue\n"
"	default[n++] = lightorange\n"
"	default[n++] = lightpurple\n"
"	default[n++] = lightgrey\n"
"	default[n++] = lightpink\n"
"	default[n++] = greygreen\n"
"	default[n++] = yellow\n"
"	default[n++] = paleblue\n"
"	default[n++] = palered\n"
"	default[n++] = palegreen\n"
"	default[n++] = paleorange\n"
"	default[n++] = paleviolet\n"
"	default[n++] = cyan\n"
"	OFS = \"\\t\"\n"
"}\n"
"function setdefcols(	n, i){\n"
"	if((n = length(default)) <= 0){\n"
"		print \"E\", \"no colors to hand\"\n"
"		return\n"
"	}\n"
"	for(i in CL)\n"
"		if(!(i in CL))\n"
"			CL[i] = default[i % n]\n"
"}\n"
"function resetcols(	i){\n"
"	deselect()\n"
"	for(i in CL)\n"
"		CL[i] = CL[i]\n"
"}\n"
"function cmd(code){\n"
"	if(code == \"FHJ142\"){	# wing to proceed to targets\n"
"		if(++fnr == nd + 1)\n"
"			cmd(\"FGD135\")\n"
"		else{\n"
"			print deferred[fnr]\n"
"			loadbatch()\n"
"		}\n"
"	}else if(code == \"FJJ142\"){	# mission completed, returning\n"
"		die = 1\n"
"		cmd(\"FHJ142\")\n"
"	}else if(code == \"OPL753\"){	# wing to contact base immediately\n"
"		loadbatch()\n"
"		if(!crm114)\n"
"			setdefcols()\n"
"		print \"R\"\n"
"		crm114 = 1\n"
"	}else if(code == \"FGD135\"){	# wing attack plan R\n"
"		if(crm114 || fnr < nd + 1)\n"
"			return\n"
"		crm114 = 1\n"
"		loadbatch()\n"
"		setdefcols()\n"
"		if(die)\n"
"			quit()\n"
"		print (noreset ? \"r\" : \"R\")\n"
"	}\n"
"}\n"
"function exportlayout(f){\n"
"	print \"o\", f\n"
"}\n"
"function importlayout(f){\n"
"	if(crm114 == 1)\n"
"		print \"i\", f\n"
"	else{\n"
"		deferred[++nd] = \"i\\t\" f \"\\n\"\n"
"		noreset = 1\n"
"	}\n"
"}\n"
"function readctab(f){\n"
"	if(crm114 == 1)\n"
"		print \"t\", f\n"
"	else\n"
"		deferred[++nd] = \"t\\t\" f \"\\n\"\n"
"}\n"
"function readcsv(f){\n"
"	if(crm114 == 1)\n"
"		print \"f\", f\n"
"	else\n"
"		deferred[++nd] = \"f\\t\" f \"\\n\"\n"
"}\n"
"function checknodeid(i){\n"
"	# FIXME: test id in node\n"
"	return 1\n"
"}\n"
"function checknodename(name){\n"
"	if(!(name in id)){\n"
"		print \"E\\tno such node: \" name\n"
"		return 0\n"
"	}\n"
"	return 1\n"
"}\n"
"function edgeinfostr(u, v, a, b, e,	s){\n"
"	s = node[u] a node[v] b\n"
"	if(e == \"\")\n"
"		return s\n"
"	xxx = \"\"	# has to be global for eval\n"
"	xxe = e\n"
"	for(a in EATTACHED){\n"
"		eval(\"{ xxx = (xxe in \" a \") ? \" a \"[xxe] : \\\"\\\" }\")\n"
"		if(xxx != \"\"){\n"
"			if(a ~ /^e..$/)\n"
"				a = substr(a, 2)\n"
"			s = s \" \" a \"=\" xxx\n"
"		}\n"
"	}\n"
"	return s\n"
"}\n"
"function edgeinfo(w, e,	u, v, a, b){\n"
"	u = w >> 32\n"
"	v = w >> 2 & 0x3fffffff\n"
"	if(!checknodeid(u) || !checknodeid(v))\n"
"		return\n"
"	a = w & 1 ? \"-\" : \"+\"\n"
"	b = w & 2 ? \"-\" : \"+\"\n"
"	info(\"Edge: \" edgeinfostr(u, v, a, b, e))\n"
"}\n"
"function findnode(name,	i){\n"
"	if(!checknodename(name))\n"
"		return\n"
"	i = id[name]\n"
"	expand1(i)\n"
"	commit(1)\n"
"	resetcols()\n"
"	selectnodebyid(i)\n"
"	print \"N\", i\n"
"}\n"
"# FIXME: cache it?\n"
"function nodeinfostr(i,	a, s){\n"
"	s = node[i] \", LN=\" LN[i]\n"
"	xxx = \"\"	# has to be global for eval\n"
"	xxi = i\n"
"	for(a in ATTACHED){\n"
"		if(a == \"degree\" || a == \"LN\" || a == \"CL\")\n"
"			continue\n"
"		eval(\"{ xxx = (xxi in \" a \") ? \" a \"[xxi] : \\\"\\\" }\")\n"
"		if(xxx != \"\")\n"
"			s = s \" \" a \"=\" xxx\n"
"	}\n"
"	return s\n"
"}\n"
"function selinfostr(	i, l, n, m, s){\n"
"	if(length(selected) == 0)\n"
"		return \"\"\n"
"	# very deliberate and assuming nodes for now\n"
"	if(length(selected) == 1)\n"
"		for(i in selected)\n"
"			return nodeinfostr(i)\n"
"	l = 0\n"
"	s = \"\"\n"
"	n = m = 0\n"
"	for(i in selected){\n"
"		l += LN[i]\n"
"		if(m < 5){\n"
"			m = length(s)\n"
"			s = s (m == 0 ? \"\" : \",\") node[i]\n"
"		}else if(n == 0){\n"
"			n++\n"
"			s = s \",...\"\n"
"		}\n"
"	}\n"
"	s = \"Selected: \" s\n"
"	if(length(selected) == 1)\n"
"		return s \", length=\" l\n"
"	return s \"; total length=\" l \" in \" length(selected) \" nodes\"\n"
"}\n"
"function nodeinfo(i,	name, s){\n"
"	if(!checknodeid(i))\n"
"		return\n"
"	s = \"Node: \" nodeinfostr(i)\n"
"	info(s)\n"
"}\n"
"function deselect(	i){\n"
"	selinfo = \"\"\n"
"	for(i in selected)\n"
"		CL[i] = CL[i]\n"
"	delete selected\n"
"}\n"
"function deselectnodebyid(i,	col){\n"
"	if(!checknodeid(i))\n"
"		return\n"
"	if(!(i in selected)){\n"
"		print \"E\\tdeselect: not selected: \" i\n"
"		return\n"
"	}\n"
"	if(length(selected) == 1){\n"
"		deselect()\n"
"		return\n"
"	}\n"
"	delete selected[i]\n"
"	selinfo = selinfostr()\n"
"	CL[i] = CL[i]\n"
"}\n"
"function deselectnode(name,	i){\n"
"	if(!checknodename(name))\n"
"		return\n"
"	deselectnodebyid(id[name])\n"
"}\n"
"function showselected(){\n"
"	selinfo = selinfostr()\n"
"	refresh()\n"
"}\n"
"function selectnodebyid(i, noshow){\n"
"	if(!checknodeid(i) || i in selected)\n"
"		return\n"
"	selected[i] = 0\n"
"	if(!noshow)\n"
"		showselected()\n"
"}\n"
"function selectall(i){\n"
"	for(i in LN)\n"
"		selectnodebyid(i, 1)\n"
"}\n"
"function selectnode(name){\n"
"	if(!checknodename(name))\n"
"		return\n"
"	selectnodebyid(id[name], 1)	# FIXME\n"
"}\n"
"function toggleselect(i){\n"
"	if(!checknodeid(i))\n"
"		return\n"
"	if(i in selected)\n"
"		deselectnodebyid(i)\n"
"	else\n"
"		selectnodebyid(i)\n"
"}\n"
"function reselectnode(i){\n"
"	if(!checknodeid(i))\n"
"		return\n"
"	deselect()\n"
"	selectnodebyid(i)\n"
"}\n"
"# FIXME: can't be variadic, unless in C\n"
"#function collapse(i){\n"
"#	if(i != \"\"){\n"
"#		if(!checknodeid(i))\n"
"#			return\n"
"#		collapse1(i)\n"
"#	}else{\n"
"#		for(i in selected)\n"
"#			collapse1(i)\n"
"#	}\n"
"#	commit()\n"
"#	deselect()\n"
"#}\n"
"# not deselecting\n"
"function expand(i){\n"
"	if(i != \"\"){\n"
"		if(!checknodeid(i))\n"
"			return\n"
"		expand1(i)\n"
"	}else if(length(selected) > 0){\n"
"		for(i in selected)\n"
"			expand1(i)\n"
"	}else\n"
"		expandall()\n"
"	commit()\n"
"	resetcols()\n"
"}\n"
"function groupby(tag, incl, cm,	acc){\n"
"	delete acc\n"
"	m_ = n_ = 0	# have to be global for eval\n"
"	if(cm == \"\")\n"
"		cm = \"defgrp\"\n"
"	else if(!(cm in SYMTAB)){\n"
"		print \"E\\tno such color palette\"\n"
"		return\n"
"	}\n"
"	eval(\"{n_ = length(\"cm\")}\")\n"
"	if(n_ <= 1){\n"
"		print \"E\\tinvalid color palette\"\n"
"		return\n"
"	}\n"
"	if(incl == \"\")\n"
"		eval(\"{for(i in \"tag\"){ c = \"tag\"[i]; if(!(c in acc)){ if(int(c) != 0) acc[c] = c; else acc[c] = m_++}; CL[i] = \"cm\"[acc[c] % n_] } }\")\n"
"	else\n"
"		eval(\"{for(i in CL){ if(!(i in \"tag\")){ c = translucent }else{ c = \"tag\"[i]; if(c !~ /\"incl\"/) c = translucent; else{ if(!(c in acc)) acc[c] = m_++; c = \"cm\"[acc[c] % n_] }}; CL[i] = c}}\")\n"
"	if(m_ > n_)\n"
"		print \"warning: more categories than colors\"\n"
"	delete acc\n"
"}\n"
"function quit(){\n"
"	print \"!\"\n"
"}\n"
"# too complicated if nested, and temporary anyway; would ideally expand\n"
"# other tags into tag[i]\n"
"function subexpr(s, v, fn,	i, pred){\n"
"	i = match(s, \"\\][ 	]*=[^=]\")\n"
"	# error check: i not 0; only sub expression up to } or ; etc\n"
"	pred = substr(s, 1, i-1)\n"
"	if(pred !~ /[^a-zA-Z0-9\" \\t]/ \\\n"
"	&& pred !~ /[^ \\t]+[ \\t]+in[ \\t]+[^ \\t]+/ \\\n"
"	&& pred !~ /^[ \\t]*i[ \\t]*$/)\n"
"		return\n"
"	s = substr(s, RSTART+RLENGTH-1)\n"
"	if(fn != \"\")\n"
"		$0 = \"for(i in \" v \") if(\" pred \"){ \" fn \"(i, \" s \")}\"\n"
"	else if(pred ~ /^[ \\t]*i[ \\t]*$/)\n"
"		$0 = \"for(i in \" v \"){ \" v \"[i]=\" s \"}\"\n"
"	else\n"
"		$0 = \"for(i in \" v \") if(\" pred \"){ \" v \"[i]=\" s \"}\"\n"
"}\n"
"crm114 && /^[	 ]*[A-Za-z][A-Za-z0-9 ]*\\[.*\\] *= */{\n"
"	i = index($0, \"[\")\n"
"	v = substr($0, 1, i - 1)\n"
"	s = substr($0, i + 1)\n"
"	subexpr(s, v)\n"
"}\n"
"{\n"
"	eval(\"{\" $0 \"}\")\n"
"}\n";
